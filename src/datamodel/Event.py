from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from typing import List, Optional

from src.datamodel.ExperimentConfig import ExperimentEvent, ExperimentTimeInterval
from src.datamodel.DataConstant import CodeSystem
from src.datamodel.DataColumns import CommonTables as ct, CommonColumns as cc


@dataclass(frozen=True)
class EventCategoryValue:
    name: str
    code_systems: List[str]


class EventCategory(Enum):
    Patient = EventCategoryValue('patient', ['patient'])
    Diagnosis = EventCategoryValue('diagnosis', [CodeSystem.icd10cm, CodeSystem.icd9cm])
    Medication = EventCategoryValue('medication', [CodeSystem.RxNorm])
    Procedures = EventCategoryValue('procedure',
                                    [CodeSystem.icd10pcs, CodeSystem.icd9cm,
                                     CodeSystem.cpt, CodeSystem.hcpcs,
                                     CodeSystem.snomed])
    VitalSign = EventCategoryValue('vital sign', [CodeSystem.loinc])
    LabResult = EventCategoryValue('lab result', [CodeSystem.loinc, CodeSystem.tnx])

    @staticmethod
    def from_string(value: str) -> Optional[EventCategory]:
        for ecat in EventCategory:
            if value == ecat.value.name:
                return ecat
        return None


@dataclass(frozen=True)
class EventTimeInterval:
    """min and max days number counting from the applied event"""
    min_t: int
    max_t: int

    @staticmethod
    def from_experiment_event_period(exp_p: Optional[ExperimentTimeInterval]) -> Optional[EventTimeInterval]:
        if exp_p is None:
            return None

        return EventTimeInterval(exp_p.get_min_t_days(), exp_p.get_max_t_days())


@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=True)
class Event:
    """
    Patient event for network building.
    """
    id: str
    category: EventCategory
    codes: Optional[list] = None
    negation: bool = False
    include_subcodes: bool = False
    exclusion_period: EventTimeInterval = None
    exclusion_events: list[Event] = None
    having_period: EventTimeInterval = None
    having_events: list[Event] = None
    period: EventTimeInterval = None

    # since autogenerated hash use each field and list is mutable object and can not deliver stable hash value
    # overwrite has function using tuple instead of list
    def __hash__(self):
        return hash((self.category, tuple(self.codes), self.negation, self.include_subcodes, self.exclusion_period,
                     tuple(self.exclusion_events), tuple(self.having_events), self.having_period, self.period))

    def has_attribute_events(self):
        return self.exclusion_events or self.having_events

    @staticmethod
    def from_experiment_event(experiment_event: ExperimentEvent) -> Optional[Event]:
        id = experiment_event.id
        category = EventCategory.from_string(experiment_event.category)
        if category is None:
            raise ValueError(f'Unknown event category {experiment_event.category}')
        if not experiment_event.codes:
            return Event(id=id, category=category, negation=experiment_event.negation)
        codes = experiment_event.codes
        codes = [c.strip() for c in codes]

        # to prevent letter case error for death event make patient event code uppercase
        if category == EventCategory.Patient:
            codes = [c.upper() for c in codes]

        if experiment_event.exclude and experiment_event.exclude.events:
            excl_period = EventTimeInterval.from_experiment_event_period(experiment_event.exclude.period)
            excl_events = [Event.from_experiment_event(e) for e in experiment_event.exclude.events]
        else:
            excl_period = None
            excl_events = None

        if experiment_event.having and experiment_event.having.events:
            having_period = EventTimeInterval.from_experiment_event_period(experiment_event.having.period)
            having_events = [Event.from_experiment_event(e) for e in experiment_event.having.events]
        else:
            having_period = None
            having_events = None

        period = EventTimeInterval.from_experiment_event_period(experiment_event.period)

        event = Event(
            id=id,
            codes=codes,
            category=category,
            negation=experiment_event.negation,
            include_subcodes=experiment_event.include_subcodes,
            exclusion_period=excl_period,
            exclusion_events=excl_events,
            having_period=having_period,
            having_events=having_events,
            period=period
        )

        return event

    def get_data_table(self) -> str:
        if self.category == EventCategory.Patient:
            return ct.patient
        elif self.category == EventCategory.Diagnosis:
            return ct.diagnosis
        elif self.category == EventCategory.Medication:
            return ct.medication
        elif self.category == EventCategory.Procedures:
            return ct.procedures
        elif self.category == EventCategory.VitalSign:
            return ct.vital_sign
        elif self.category == EventCategory.LabResult:
            return ct.lab_result
        else:
            raise ValueError(f'Unknown event category: {self.category}')


class EventConstant:
    DEATH = 'DEATH'
